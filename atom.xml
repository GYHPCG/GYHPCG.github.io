<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A tour of my learing</title>
  
  <subtitle>All in CS</subtitle>
  <link href="https://gyhpcg.gihthub.io/atom.xml" rel="self"/>
  
  <link href="https://gyhpcg.gihthub.io/"/>
  <updated>2023-12-17T08:29:39.799Z</updated>
  <id>https://gyhpcg.gihthub.io/</id>
  
  <author>
    <name>pancg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据原理技术</title>
    <link href="https://gyhpcg.gihthub.io/2023/12/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    <id>https://gyhpcg.gihthub.io/2023/12/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E6%8A%80%E6%9C%AF/</id>
    <published>2023-12-17T07:21:27.000Z</published>
    <updated>2023-12-17T08:29:39.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数据原理期末复习"><a href="#大数据原理期末复习" class="headerlink" title="大数据原理期末复习"></a>大数据原理期末复习</h1><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="Hadoop的特点"><a href="#Hadoop的特点" class="headerlink" title="Hadoop的特点"></a>Hadoop的特点</h3><ol><li>扩容能力(Scalable)：<br>Hadoop是在计算机集群内分配并完成计算任务，集群可以方便的扩展到数以千个节点</li><li>低成本(Economical)：<br> Hadoop通过普通廉价的机器组成服务器集群来分发以及处理数据，以至于成本很低</li><li>高效率(Efficient)：<br>Hadoop可以在节点之间动态并行的移动数据，使得速度非常快</li><li>可靠性(Rellable)：<br>能自动维护数据的多份复制，并且在任务失败后能自动的重新部署计算任务</li></ol><p><img src="/image.png" alt="Alt text"></p><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><h4 id="NN和SNN"><a href="#NN和SNN" class="headerlink" title="NN和SNN"></a>NN和SNN</h4><p>元数据管理流程图:<br><img src="/../img/bigData/snn_nn.png" alt="SNN和NN"></p><ol><li><p>NN(NameNode)</p><ul><li><p>NN是整个文件系统的管理节点（上传、下载、更改、删除）。它维护着整个文件系统的文件目录树，文件&#x2F;目录的元数据(meta data)和每个文件对应的数据块列表。接收用户的操作请求。</p></li><li><p>文件包括：</p><ul><li>fsimage: 元数据镜像文件。存储某一个时刻的NameNode内元数据信息</li><li>edits: 操作日志文件，NameNode启动后一些新增元信息日志。</li><li>fstime: 保存最近异常checkpoint的时间</li></ul></li><li><p>以上文件时保存在Linux的文件系统中。</p><ul><li>hdfs-site.xml的dfs.namenode.name.dir属性</li></ul></li></ul></li><li><p>SNN(Secondary NameNode)</p><ul><li>作用:<ul><li>辅助NN: SNN不是NN的热备份，而是辅助NN处理FSimage(文件系统的元数据)和Edits(记录了对文件系统所做更改的日志)。</li><li>合并edits和Fsimage: 定期合并fsimage和edits，减少NN重启时恢复文件系统状态的时间。合并过程称为<strong>Checkpoint</strong></li><li>减小NN的负担：通过定期创建Fsimage的检查点，SNN减轻了NN的内存和存储压力</li><li>灾难恢复：在NN发生故障时，SNN中的数据可以用于恢复文件系统的状态，虽然这不是它的主要目的。<br>  <strong>注意</strong>：SNN不是NN的热备份，他不能在NN故障时自动接管其职责。在hadoop2.x版本中，为了提供更高的可用性和灾难恢复能力，引入了HA(高可用性)架构，其中包括使用Active&#x2F;Standby两个NN</li></ul></li></ul></li><li><p>元数据管理流程图:<br><img src="/../img/bigData/snn_nn.png" alt="SNN和NN"><br>根据上图，可知NN和SNN的工作流程为：</p><ol><li>第一阶段：NN启动<ul><li>第一次启动NN格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存</li><li>客户端对元数据进行增删改的请求</li><li>NN记录操作日志，更新滚动日志</li><li>NN在内存中对数据进行增删查改</li></ul></li><li>第二阶段：SNN工作<ul><li>SNN询问NN是否需要CheckPoint。直接带回NN是否执行检查点操作结果</li><li>SNN请求执行CheckPoint</li><li>NN滚动正在写的Edits日志</li><li>将滚动前的编辑日志和镜像文件拷贝到SNN.</li><li>SNN加载编辑编辑日志和镜像文件到内存，并合并</li><li>生成新的镜像文件fsimage.checkpoint</li><li>拷贝fsimage.chkpoint到NN</li><li>NN 将fsimage.chkpoint重新命名为fsimage</li></ul></li></ol></li><li><p>CheckPoint</p><ol><li>fs.checkpoint.period指定两次CheckPoint的最大时间间隔默认为3600秒(1个小时)</li><li>fs.checkpoint.size规定edits文件的最大值，一旦超过这个值则强制checkpoint,不管是否到达最大时间间隔，默认是64M<br> [hdfs-default.xml]<pre><code class="xml">&lt;!-- 定时一小时 --&gt;    &lt;property&gt;    &lt;name&gt;dfs.namenode.checkpoint.period&lt;/name&gt;    &lt;value&gt;3600&lt;/value&gt;    &lt;/property&gt;    &lt;!-- 一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次 --&gt;    &lt;property&gt;    &lt;name&gt;dfs.namenode.checkpoint.txns&lt;/name&gt;    &lt;value&gt;1000000&lt;/value&gt;    &lt;description&gt;操作动作次数&lt;/description&gt;    &lt;/property&gt;    &lt;property&gt;    &lt;name&gt;dfs.namenode.checkpoint.check.period&lt;/name&gt;    &lt;value&gt;60&lt;/value&gt;    &lt;description&gt; 1分钟检查一次操作次数&lt;/description&gt;    &lt;/property &gt;</code></pre></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大数据原理期末复习&quot;&gt;&lt;a href=&quot;#大数据原理期末复习&quot; class=&quot;headerlink&quot; title=&quot;大数据原理期末复习&quot;&gt;&lt;/a&gt;大数据原理期末复习&lt;/h1&gt;&lt;h2 id=&quot;Hadoop&quot;&gt;&lt;a href=&quot;#Hadoop&quot; class=&quot;head</summary>
      
    
    
    
    <category term="学习总结" scheme="https://gyhpcg.gihthub.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="big data" scheme="https://gyhpcg.gihthub.io/tags/big-data/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://gyhpcg.gihthub.io/2023/11/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gyhpcg.gihthub.io/2023/11/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-11-23T10:22:05.000Z</published>
    <updated>2023-11-23T11:55:37.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="一-设计模式六大原则"><a href="#一-设计模式六大原则" class="headerlink" title="一. 设计模式六大原则"></a>一. 设计模式六大原则</h2><p>总原则–开闭原则</p><blockquote><p>一个软件实体一个对扩展开放，对修改关闭</p></blockquote><ol><li>单一职责原则<blockquote><p>一个类应该只有一个引起发生变化的原因</p></blockquote></li><li>里氏替换原则<blockquote><p>所有使用父类的地方都可以用子类对象来替换（子类对父类的方法尽量不要重写和重载）</p></blockquote></li><li>依赖倒转原则<blockquote><ol><li>上层模块不应该依赖底层模块，它们都应该依赖抽象</li><li>抽象不应该依赖于细节，细节应该依赖于抽象</li></ol></blockquote></li><li>接口隔离原则<blockquote><ol><li>客户端不应该依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ol></blockquote></li><li>迪米特原则（最小知道原则）<blockquote><p>只与你的直接朋友交谈，不跟“陌生人”说话<br>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public 方法提供给外部</p></blockquote></li><li>合成复用原则（组合优先于继承）<blockquote><p>尽量使用对象组合&#x2F;聚合，而是继承关系达到软件复用的目的</p></blockquote></li></ol><h2 id="二-设计模式的三大类"><a href="#二-设计模式的三大类" class="headerlink" title="二. 设计模式的三大类"></a>二. 设计模式的三大类</h2><ol><li>创建型模式：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</li><li>结构型模式：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。 适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。<blockquote><p>策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p></blockquote></li></ol><h2 id="三-23种设计模式"><a href="#三-23种设计模式" class="headerlink" title="三. 23种设计模式"></a>三. 23种设计模式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;一-设计模式六大原则&quot;&gt;&lt;a href=&quot;#一-设计模式六大原则&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习总结" scheme="https://gyhpcg.gihthub.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="设计模式" scheme="https://gyhpcg.gihthub.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建测试</title>
    <link href="https://gyhpcg.gihthub.io/2023/11/06/hexo%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95/"/>
    <id>https://gyhpcg.gihthub.io/2023/11/06/hexo%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95/</id>
    <published>2023-11-06T04:57:10.000Z</published>
    <updated>2023-11-06T05:23:35.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="first-test"><a href="#first-test" class="headerlink" title="first test"></a>first test</h1><h1 id="second-test"><a href="#second-test" class="headerlink" title="second test"></a>second test</h1><h2 id="hello-test"><a href="#hello-test" class="headerlink" title="hello test"></a>hello test</h2>]]></content>
    
    
    <summary type="html">关于hexo搭建的一些测试</summary>
    
    
    
    
    <category term="environment" scheme="https://gyhpcg.gihthub.io/tags/environment/"/>
    
  </entry>
  
  <entry>
    <title>2023rcore第二阶段学习总结</title>
    <link href="https://gyhpcg.gihthub.io/2023/11/05/rcore_study/"/>
    <id>https://gyhpcg.gihthub.io/2023/11/05/rcore_study/</id>
    <published>2023-11-05T15:09:21.000Z</published>
    <updated>2023-11-06T13:12:55.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023rcore第二阶段学习总结和个人与计算机系统的漫游"><a href="#2023rcore第二阶段学习总结和个人与计算机系统的漫游" class="headerlink" title="2023rcore第二阶段学习总结和个人与计算机系统的漫游"></a>2023rcore第二阶段学习总结和个人与计算机系统的漫游</h1><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>与 <a href="https://github.com/LearningOS">rcore开源操作系统训练营</a> 的相识，算是一个很偶然的机会吧。我与计算机结识很晚，在我上大学后，才从一个对计算机连打字都不会的人到慢慢熟练使用以及熟悉各种技术的人。与操作系统(Linux)结识，是大一下学期的 计算机系统基础课(教程是那本鼎鼎大名的 <strong>深入了解计算机系统</strong>)，那节课开启了我Linux的漫游旅途。</p><h2 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h2><p>在我刚接触计算机的时候，一直认为开发出一个web网站或者APP，就是一件特别特别酷的事情。在整个刚接触计算机的事情，写出一个web网页或者APP便是我一直想要做的事。但后来，大一结束的暑假，学习了一些这方面的技术，扒开了web的真实面目，便慢慢失去了很多兴趣，曾经很酷的事情，突然感觉很无味了。所幸的是，在这个时候，学校的 <strong>OS</strong> 课开了，杨老师是一名非常知识渊博、热爱体系结构的老师，他 <strong>OS</strong> 第一门课留给我们的作业便是</p><blockquote><p>下载linux内核源码，并往内核中添加自定义系统调用</p></blockquote><p>这算是我开启了我正式与操作系统内核接触的旅途。永远无法忘却第一次下载linux内核源码，然后编译的时候，满屏报错的电脑界面，特别是每次编译的时候，都会让我等待很久，几乎每次都是编译了三十多分钟，然后给我报错，如此循环往复……最后终于把代码编译完成。第一次进入<strong>kernel</strong> 目录下，进入代码里面，映入眼帘的是 <strong>Linus Torvalds</strong> 的大名，那是我第二次那么激动(第一次激动的时候是第一次敲出 “Hello, World”)。最后在各种操作之下，各种文件之间来回修改的条件下，我终于让自己自定义的一个系统调用成功运行了起来，那一瞬间，像是打开了潘多拉的魔盒，从此我开始对体系结构、操作系统方向的东西产生了很大兴趣，便也萌生了写一个OS的想法，从此整个想法，便一直根深蒂固着。</p><h2 id="遇见rcore"><a href="#遇见rcore" class="headerlink" title="遇见rcore"></a>遇见rcore</h2><p>诚恳的说，我是因为心中那个根深蒂固的想法才会有机会遇见rcore，刚开始的时候，我其实知道的是 <strong>ucore</strong>, 后来因为个人非常喜欢c++，而某段的时间里，网上的各样信息都在告诉我 <strong>Rust</strong> 是c++的强大竞争者，<strong>Rust</strong> 是如何的安全，如何的高效。便萌发了我对这一门新型语言的兴趣。</p><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust:"></a>Rust:</h3><p>第一次用Rust的时候，它的cargo便惊艳了我很久，用c++的时候，每次安装第三方包，亦或是换个平台，编译东西，都会让我折磨很久，总是在各种编译器之间的实现困惑，msvc有的特性，在gcc有时候却无法运行，有时候在gcc能够运行的东西，在clang也无法运行。同样让人痛苦的时候，c++20&#x2F;c++23都出了很久了，但是不同编译器的支持却是层出不穷……。换到Rust，突然很多东西便让人清爽了许多。也便逐渐开始了学习Rust的旅途。</p><h3 id="risc-v"><a href="#risc-v" class="headerlink" title="risc-v:"></a>risc-v:</h3><p>对于risc-v的了解，在开始rcore之前，我也只知道它是开源的，文档内容少(远没有X86和Arm那样内容复杂和繁冗)。后来了解了一下龙芯，<a href="https://oscpu.github.io/ysyx/">一生一芯</a>等，便也对risc-v有了极大兴趣，恰逢此时，rcore便出现在了我面前。</p><h3 id="rcore"><a href="#rcore" class="headerlink" title="rcore:"></a>rcore:</h3><p><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/index.html">rcore Book</a> 的娓娓道来，特别是以各种史前生物 来描述，增加了一番故事书的趣味。而<a href="http://learningos.cn/rCore-Tutorial-Guide-2023A/">Guide</a>则能够快速地让我明白了代码地框架，每个文件，每个模块是什么样的功能。但无奈个人基础不好，所以大部分时间还是在看 Book。本次实验让我们实现操作系统核心的几个重要功能：</p><ol><li>多到程序与分时多道任务</li></ol><ul><li>Lab1 需要完善系统调用。对于 sys_task_info 系统调用，我们在 TCP 添加相应字段处理即<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_task_info</span>(ti: *<span class="keyword">mut</span> TaskInfo) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">        <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        *ti = TaskInfo&#123;</span><br><span class="line">            status:<span class="title function_ invoke__">get_current_status</span>(),</span><br><span class="line">            syscall_times:<span class="title function_ invoke__">get_syscall_times</span>(),</span><br><span class="line">            time : (<span class="title function_ invoke__">get_time_us</span>() - <span class="title function_ invoke__">get_current_start_time</span>()) / <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>虚拟内存管理  </p><p> 这部分的内容中，为 Rcore 引入了虚拟内存，为地址空间加上了一层抽象，# 地址空间<br> 刚学计算机的时候，个人非常总喜欢将所有代码放在一个文件里，觉得分开各种代码很是麻烦。后来因为学习深入，开始对分离代码，抽象多了很多体会。特别是在学计算机网络的TCP&#x2F;IP模型和操作系统的时候，对<strong>抽象，加层</strong>的思想确实是不断体会，不断明白了那句话“在计算机中，没有什么是不能加一层解决不了的”。现在来好好感受在ch4中的抽象加一层。</p><ol><li><p>为什么要添加一层抽象层：</p><ul><li>从应用开发的角度看，需要应用程序决定自己会被加载到哪个物理地址运行，需要直接访问真实的物理内存。这就要求应用开发者对于硬件的特性和使用方法有更多了解，产生额外的学习成本，也会为应用的开发和调试带来不便</li><li>从内核的角度来看，将直接访问物理内存的权力下放到应用会使得它难以对应用程序的访存行为进行有效管理，已有的特权级机制亦无法阻止很多来自应用程序的恶意行为。</li></ul></li><li><p>该抽象层要完成的目标：</p><ul><li><p>透明 ：应用开发者可以不必了解底层真实物理内存的硬件细节，且在非必要时也不必关心内核的实现策略， 最小化他们的心智负担；</p></li><li><p>高效 ：这层抽象至少在大多数情况下不应带来过大的额外开销；</p></li><li><p>安全 ：这层抽象应该有效检测并阻止应用读写其他应用或内核的代码、数据等一系列恶意行为。</p></li></ul></li></ol></li><li><p>进程管理</p><ul><li>对于进程、程序、可执行文件等的了解更加深入了<ol><li>进程是在操作系统管理下的程序的一次执行过程，程序是一个静态的概念。</li><li>可执行文件是一张“蓝图”：一张编译器解析源代码之后总结出的一张记载如何利用各种硬件资源进行一轮生产流程的 <strong>蓝图</strong></li><li>加载同一个可执行文件的两个进程也是不同的：它们的启动时间、占据的硬件资源、输入数据均有可能是不同的，这些条件均会导致它们是不一样的执行过程。</li><li>对于创建进程需要fork()和exec()两个系统调用而不只是一个系统调用。两个组合更加灵活，fork是为了 exec 一个新应用提供空间，然后exec可以读取不同的elf文件，执行不同的操作。</li></ol></li></ul></li><li><p>文件系统(未完待续)</p></li><li><p>并发(未完待续)</p></li></ol><p>但很可惜，因为个人基础和时间还有其他各种各样的原因，个人并没有完成五个实验，前面三个实验也只是勉强完成（虽然运行过了，但还是有很多东西之间还不明白）。接下来的时间，我将好好把先前没有弄明白的知识点再好好梳理一遍。并将继续做完还没有先前没有做完的工作。向训练营各位优秀的同学学习，以后要多写博客，多写博客(这次学到的一个优秀习惯)，及时梳理知识。纸上得来终觉浅，绝知此事要躬行！！！。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2023rcore第二阶段学习总结和个人与计算机系统的漫游&quot;&gt;&lt;a href=&quot;#2023rcore第二阶段学习总结和个人与计算机系统的漫游&quot; class=&quot;headerlink&quot; title=&quot;2023rcore第二阶段学习总结和个人与计算机系统的漫游&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="学习总结" scheme="https://gyhpcg.gihthub.io/categories/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Rust" scheme="https://gyhpcg.gihthub.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://gyhpcg.gihthub.io/2023/11/05/hello-world/"/>
    <id>https://gyhpcg.gihthub.io/2023/11/05/hello-world/</id>
    <published>2023-11-05T14:28:16.264Z</published>
    <updated>2023-11-06T03:22:56.979Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
